/* Copyright (c) 2013, Ben Noordhuis <info@bnoordhuis.nl>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef QUEUE_H_
#define QUEUE_H_

#include <stddef.h>

// JAMLEE:(L0): 队列。含有这个结构体的
// https://stackoverflow.com/questions/13740983/how-are-the-ascii-diagrams-in-rfcs-generated
//
// 1. 队列中，2 个节点的情况
//         +---------------------+
//         |                     |
//  +------v------+       +-------------+
//  |     next    +------>+     next    |
//  +-------------+       +-------------+
//  |     prev    +<------+     prev    |
//  +-------------+       +-------------+
//         |                     ^
//         +---------------------+

// 2. 队列中， 3 个节点的情况
//      +-------------+       +-------------+
// ---->+     next    +------>+     next    +-----
// |    +-------------+       +-------------+    |
// | ---+     prev    +<------+     prev    +<--------
// | |  +-------------+       +-------------+    |   |
// | |                                           |   |
// | |                                           |   |
// | |                                           |   |
// | |             +-------------+               |   |
// ----------------+     next    +<--------------+   |
//   |             +-------------+                   |
//   ------------->+     prev    +--------------------
//                 +-------------+
// 特征：
// 1. 循环队列，没有所谓的头节点和尾结点，可以选择任何 1 个节点作为头结点。
typedef void *QUEUE[2];

// JAMLEE: QUEUE_NEXT(q) 的类型和 q 一样，q 的类型是 QUEUE *。这里把 QUEUE 当做 1 个整体来看。
// 1. (*(q)) 得到数组首地址 QUEUE; QUEUE[0], 数组第0个元素; QUEUE[1], 数组第1个元素;
// 2. &((*(q))[0])) 当前元素的存放「上一节点地址」和「下一节点的地址」的「变量的地址」。
// 3. (QUEUE **) &((*(q))[0]) 是把类型变为 QUEUE **。QUEUE 是数组首地址，QUEUE * 是指向数组首地址的指针。QUEUE ** 是存储这个指针的。
// 4. * (QUEUE **) &((*(q))[0]), QUEUE ** 解引用，得到 QUEUE *。指向 QUEUE 的指针。回到了 QUEUE 的类型。
/* Private macros. */
#define QUEUE_NEXT(q)       (*(QUEUE **) &((*(q))[0]))
#define QUEUE_PREV(q)       (*(QUEUE **) &((*(q))[1]))

// JAMLEE: 
// QUEUE_NEXT 得到 QUEUE *， 指向下一个节点的 QUEUE; QUEUE_PREV(QUEUE_NEXT(q)) ，得到 QUEUE *，指向下一个节点的上一个节点。插入队列会用到。
#define QUEUE_PREV_NEXT(q)  (QUEUE_NEXT(QUEUE_PREV(q)))
#define QUEUE_NEXT_PREV(q)  (QUEUE_PREV(QUEUE_NEXT(q)))

/* Public macros. */
#define QUEUE_DATA(ptr, type, field)                                          \
  ((type *) ((char *) (ptr) - offsetof(type, field)))

/* Important note: mutating the list while QUEUE_FOREACH is
 * iterating over its elements results in undefined behavior.
 */
#define QUEUE_FOREACH(q, h)                                                   \
  for ((q) = QUEUE_NEXT(h); (q) != (h); (q) = QUEUE_NEXT(q))

// JAMLEE: 是否是空队列
#define QUEUE_EMPTY(q)                                                        \
  ((const QUEUE *) (q) == (const QUEUE *) QUEUE_NEXT(q))

// JAMLEE: 约定当前节点的下一个作为 head。当前节点永远在队列尾部。头节点一定是空节点。
#define QUEUE_HEAD(q)                                                         \
  (QUEUE_NEXT(q))

// JAMLEE: 调用 QUEUE_NEXT 和 QUEUE_PREV。用 do while 将其包装为 1 个语句。
// 表示[0]、[1]上的元素都赋于自身的地址。传入的q 应该是某个结构体上的 queue 字段。
// 比如：UV_PROCESS_PRIVATE_FIELDS 就含有 queue, 所有多个 process 可以组织为 1 个队列（循环链表形式）
// QUEUE_NEXT(q) = (q); 变为 (*(QUEUE **) &((*(q))[0])) = q
#define QUEUE_INIT(q)                                                         \
  do {                                                                        \
    QUEUE_NEXT(q) = (q);                                                      \
    QUEUE_PREV(q) = (q);                                                      \
  }                                                                           \
  while (0)

// JAMLEE: QUEUE_ADD。
// 队列n加入到队列h的尾部。h 和 n 的类型 QUEUE*
//                     +-----------------------------------------------+
//                     |                                               |
//              +------v------+        +-------------+          +------+------+
//              |     next    +------->+     next    +--------->+     next    |
// h  +------>  +-----(1)-----+        +-----(2)-----+          +-----(3)-----+
//              |     prev    +<-------+     prev    +<---------+     prev    |
//              +------+------+        +-------------+          +-------+-----+
//                     |                                                ^
//                     +------------------------------------------------+

//              queue h, this is a queue, not node of a queue

//                     +-----------------------------------------------+
//                     |                                               |
//              +------v------+        +-------------+          +------+------+
//              |     next    +------->+     next    +--------->+     next    |
// n  +------>  +----(4)------+        +-----(5)-----+          +-----(6)-----+
//              |     prev    +<-------+     prev    +<---------+     prev    |
//              +------+------+        +-------------+          +-------+-----+
//                     |                                                ^
//                     +------------------------------------------------+

//              queue n, this is a queue, not node of a queue


//                     +------------------------------------------------------------------------------------------------+
//                     |                                                                                                |
//              +------v------+        +-------------+          +-------------+        +-------------+          +-------+-----+
//              |     next    +------->+     next    +--------->+     next    +------->+     next    +--------->+     next    |
// h  +------>  +-----(1)-----+        +-----(2)-----+          +-----(3)-----+        +-----(5)-----+          +-----(6)-----+
//              |     prev    +<-------+     prev    +<---------+     prev    +<-------+     prev    +<---------+     prev    |
//              +------+------+        +-------------+          +-------------+        +-------------+          +-------+-----+
//                     |                                                                                                ^
//                     +------------------------------------------------------------------------------------------------+

//              got a new queue, h points to it
// 特征：
// 1. 节点4是n指向的，队列相加后，节点4已经脱离了队列。
// 步骤:
// 1. 节点3的 next 设置为节点5
// 2. 节点5的 prev 设置为节点3。
// 3. 节点1的 prev 设置为节点6。
// 4. 节点6的 next 设置为节点1。
#define QUEUE_ADD(h, n)                                                       \
  do {                                                                        \
    QUEUE_PREV_NEXT(h) = QUEUE_NEXT(n);                                       \
    QUEUE_NEXT_PREV(n) = QUEUE_PREV(h);                                       \
    QUEUE_PREV(h) = QUEUE_PREV(n);                                            \
    QUEUE_PREV_NEXT(h) = (h);                                                 \
  }                                                                           \
  while (0)

// 参考：https://www.cnblogs.com/chenyangyao/p/libuv.html
//                     +---------------------------------------------------------------------------------------------------------------------+
//                     |                                                                                                                     |
//              +------v------+        +-------------+          +-------------+      +------v------+        +-------------+          +-------+-----+
//              |     next    +------->+     next    +--------->+     next    +----->+     next    +------->+     next    +--------->+     next    |
// h  +------>  +-----(1)-----+        +-----(2)-----+          +-----(3)-----+      +----(4)------+        +-----(5)-----+          +-----(6)-----+
//              |     prev    +<-------+     prev    +<---------+     prev    +<-----+     prev    +<-------+     prev    +<---------+     prev    |
//              +------+------+        +-------------+          +-------------+      +------+------+        +-------------+          +-------+-----+
//                     |                                                                    ^                                                ^
//                     +---------------------------------------------------------------------------------------------------------------------+
//                                                                                          |
//                                                                                          +
//                                                                                          q
//                     +---------------------+
//                     |                     |
//              +------v------+       +------+------+
//              |     next    +------>+     next    |
//  n  +------> +-----(7)-----+       +-----(8)-----+
//              |     prev    +<------+     prev    |
//              +------+------+       +------+------+
//                     |                     ^
//                     +---------------------+
//
//                     +----------------------------------------------------------------------
//                     v                                                                     |
//              +------+------+       +------v------+        +-------------+          +------+------+
//              |     next    +------>+     next    +------->+     next    +--------->+     next    |
//  n  +------> +-----(7)-----+       +----(4)------+        +-----(5)-----+          +-----(6)-----+
//              |     prev    +<------+     prev    +<-------+     prev    +<---------+     prev    |
//              +------+------+       +-------------+        +-------------+          +------+------+
//                     |                                                                     ^
//                     -----------------------------------------------------------------------
// 特征：
// 1. 节点8这样的直接脱离了队列。
// 步骤：
// 1. 节点7的prev赋值为节点6。
// 2. 节点6的next设置为节点7。
// 3. 节点7的next设置为节点4。
// 4. 节点1的prev设置节点3。
// 5. 节点3的next设置为节点1。
// 6. 节点4的prev设置为节点7。
#define QUEUE_SPLIT(h, q, n)                                                  \
  do {                                                                        \
    QUEUE_PREV(n) = QUEUE_PREV(h);                                            \
    QUEUE_PREV_NEXT(n) = (n);                                                 \
    QUEUE_NEXT(n) = (q);                                                      \
    QUEUE_PREV(h) = QUEUE_PREV(q);                                            \
    QUEUE_PREV_NEXT(h) = (h);                                                 \
    QUEUE_PREV(q) = (n);                                                      \
  }                                                                           \
  while (0)

// JAMLEE：QUEUE_MOVE。
// h 后面的节点，整体转移到 n 后面。n 节点后面的节点脱离的队里。
//                     +---------------------------------------------------------------------------------------------------------------------+
//                     |                                                                                                                     |
//              +------v------+        +-------------+          +-------------+      +------v------+        +-------------+          +-------+-----+
//              |     next    +------->+     next    +--------->+     next    +----->+     next    +------->+     next    +--------->+     next    |
// h  +------>  +-----(1)-----+        +-----(2)-----+          +-----(3)-----+      +----(4)------+        +-----(5)-----+          +-----(6)-----+
//              |     prev    +<-------+     prev    +<---------+     prev    +<-----+     prev    +<-------+     prev    +<---------+     prev    |
//              +------+------+        +-------------+          +-------------+      +------+------+        +-------------+          +-------+-----+
//                     |                                                                    ^                                                ^
//                     +---------------------------------------------------------------------------------------------------------------------+
//                                                                                          |
//                                                                                          +
//                                                                                          q
//                     +---------------------+
//                     |                     |
//              +------v------+       +------+------+
//              |     next    +------>+     next    |
//  n  +------> +-----(7)-----+       +-----(8)-----+
//              |     prev    +<------+     prev    |
//              +------+------+       +------+------+
//                     |                     ^
//                     +---------------------+
//
//                      +---------------------------------------------------------------------------------------------------------------------+
//                      v                                                                                                                     |
//              +-------+-----+       +-------------+          +-------------+      +------v------+        +-------------+          +---------+---+
//              |     next    +------>+     next    +--------->+     next    +----->+     next    +------->+     next    +--------->+     next    |
//  n  +------> +-----(7)-----+       +-----(2)-----+          +-----(3)-----+      +----(4)------+        +-----(5)-----+          +-----(6)-----+
//              |     prev    +<------+     prev    +<---------+     prev    +<-----+     prev    +<-------+     prev    +<---------+     prev    |
//              +------+------+       +-------------+          +-------------+      +-------+-----+        +-------------+          +-------------+
//                     |                                                                    ^                                                ^
//                     +--------------------------------------------------------------------+------------------------------------------------+
#define QUEUE_MOVE(h, n)                                                      \
  do {                                                                        \
    if (QUEUE_EMPTY(h))                                                       \
      QUEUE_INIT(n);                                                          \
    else {                                                                    \
      QUEUE* q = QUEUE_HEAD(h);                                               \
      QUEUE_SPLIT(h, q, n);                                                   \
    }                                                                         \
  }                                                                           \
  while (0)

//            6
//            ^
//     +-------------+
//     |     prev    |    QUEUE_INSERT_HEAD
//     +-----(0)-----+                                        queue direction
//     |     next    |       +
//     +-------------+       |                          <-------------------------+
//            |--------------+
// +---------------------------------------------------------------------------------------------------------------------------------------+
//            |
//     +------v------+        +-------------+          +-------------+      +------v------+        +-------------+          +-------------+
//     |     next    +------->+     next    +--------->+     next    +----->+     next    +------->+     next    +--------->+     next    |
//     +-----(1)-----+        +-----(2)-----+          +-----(3)-----+      +----(4)------+        +-----(5)-----+          +-----(6)-----+
//     |     prev    +<-------+     prev    +<---------+     prev    +<-----+     prev    +<-------+     prev    +<---------+     prev    |
//     +-------------+        +-------------+          +-------------+      +-------------+        +-------------+          +-------------+
//                                                                                 ^
// +----------------------------------------------------------------------------------------------------------------------------------------+

//                                                                                                                                  ^
//                                                                                                                                  |
//                                                                                                                                  +
//                                                                                                                            QUEUE_INSERT_TAIL
// JAMLEE: 约定 h 是队列 head，h 和 h 的 next 之间插入 q。从队列头部入队。取得时候会从队列头部取。
#define QUEUE_INSERT_HEAD(h, q)                                               \
  do {                                                                        \
    QUEUE_NEXT(q) = QUEUE_NEXT(h);                                            \
    QUEUE_PREV(q) = (h);                                                      \
    QUEUE_NEXT_PREV(q) = (q);                                                 \
    QUEUE_NEXT(h) = (q);                                                      \
  }                                                                           \
  while (0)

// JAMLEE: 约定 h 是队列 head，h 的前面插入 q，也就是队列尾部。从队列尾部入队。
#define QUEUE_INSERT_TAIL(h, q)                                               \
  do {                                                                        \
    QUEUE_NEXT(q) = (h);                                                      \
    QUEUE_PREV(q) = QUEUE_PREV(h);                                            \
    QUEUE_PREV_NEXT(q) = (q);                                                 \
    QUEUE_PREV(h) = (q);                                                      \
  }                                                                           \
  while (0)

// JAMLEE: 从队列中移除 q 元素
#define QUEUE_REMOVE(q)                                                       \
  do {                                                                        \
    QUEUE_PREV_NEXT(q) = QUEUE_NEXT(q);                                       \
    QUEUE_NEXT_PREV(q) = QUEUE_PREV(q);                                       \
  }                                                                           \
  while (0)

#endif /* QUEUE_H_ */
